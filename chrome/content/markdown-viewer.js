window.addEventListener('load', function load(event) {
	window.removeEventListener('load', load, false);
	MarkdownViewer.init();
}, false);

// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIURI
function makeURI(aURL, aOriginCharset, aBaseURI) {
	var ioService = Components.classes["@mozilla.org/network/io-service;1"]
					.getService(Components.interfaces.nsIIOService);
	return ioService.newURI(aURL, aOriginCharset, aBaseURI);
}

/**
 * Safely parse an HTML fragment, removing any executable
 * JavaScript, and return a document fragment.
 * https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/DOM_Building_and_HTML_Insertion
 *
 * @param {Document} doc The document in which to create the
 *   returned DOM tree.
 * @param {string} html The HTML fragment to parse.
 * @param {boolean} allowStyle If true, allow <style> nodes and
 *   style attributes in the parsed fragment. Gecko 14+ only.
 * @param {nsIURI} baseURI The base URI relative to which resource
 *   URLs should be processed. Note that this will not work for
 *   XML fragments.
 * @param {boolean} isXML If true, parse the fragment as XML.
 */
function parseHTML(doc, html, allowStyle, baseURI, isXML) {
	const PARSER_UTILS = "@mozilla.org/parserutils;1";

	// User the newer nsIParserUtils on versions that support it.
	if (PARSER_UTILS in Components.classes) {
		let parser = Components.classes[PARSER_UTILS]
							   .getService(Ci.nsIParserUtils);
		if ("parseFragment" in parser)
			return parser.parseFragment(html, allowStyle ? parser.SanitizerAllowStyle : 0,
										!!isXML, baseURI, doc.documentElement);
	}

	return Components.classes["@mozilla.org/feed-unescapehtml;1"]
					 .getService(Components.interfaces.nsIScriptableUnescapeHTML)
					 .parseFragment(html, !!isXML, baseURI, doc.documentElement);
}

function BrowserSetForcedCharacterSet(aCharset) {
	var wnd = (gContextMenu ? document.commandDispatcher.focusedWindow : window);
	if ((window === wnd) || (wnd === null)) wnd = window.content;
	const Ci = Components.interfaces;
	var webNav = wnd.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation);
	var docShell = webNav.QueryInterface(Ci.nsIDocShell);
	docShell.QueryInterface(Ci.nsIDocCharset).charset = aCharset;
	webNav.reload(0);
}

if (!MarkdownViewer) {

	var MarkdownViewer = {

		init: function() {
			const appcontent = document.getElementById('appcontent');
			if (appcontent)
				appcontent.addEventListener('DOMContentLoaded', this.onPageLoad, true);
		},

		onPageLoad: function(aEvent) {
			const document = aEvent.originalTarget;
			const markdownFileExtension = /\.m(arkdown|kdn?|d(o?wn)?)(\?.*)?(#.*)?$/i;

			if (document.location.protocol !== "view-source:" &&
				markdownFileExtension.test(document.location.href) &&
				document.contentType !== "text/html") {

				var textContent = document.documentElement.textContent;
				// Empty the body
				while (document.body.firstChild) {
					document.body.removeChild(document.body.firstChild);
				}

				// Change the charset
				if (document.characterSet.toLowerCase() !== 'utf-8') {
					BrowserSetForcedCharacterSet('utf-8');
					return;
				}

				// Parse the content Markdown => HTML
				var md = markdownit({
					html: true,
					linkify: true,
					// Shameless copypasta https://github.com/markdown-it/markdown-it#syntax-highlighting
					highlight: function (str, lang) {
						if (lang && hljs.getLanguage(lang)) {
							try {
								return hljs.highlight(lang, str).value;
							} catch (__) {}
						}

						try {
							return hljs.highlightAuto(str).value;
						} catch (__) {}

						return ''; // use external default escaping
					}
				});

				var html = '<div class="container">' + md.render(textContent) + '</div>';

				// For links, copy href attribute to data-original-href, for sanitizing later. Do
				// that for both href="...", either generated by markdown-it, which uses escape(),
					// or from the original .md file, and also for HTML5-style href='...' which can
					// come from the original .md file. Assume that HTML from the original .md file is
				// well-formed. Pass any attributes left of href unchanged; allow attribute names
				// without value (e.g. xxx in <a xxx href='...'>).
				html = html.replace( /<a((\s+(?!href)[a-zA-Z-_0-9]+(=("[^"]*"|'[^']'))?)*)\s+href="([^"]*)"/gi, '<a$1 href="$5" data-original-href="$5"' );
				html = html.replace( /<a((\s+(?!href)[a-zA-Z-_0-9]+(=("[^"]*"|'[^']'))?)*)\s+href='([^']*)'/gi, "<a$1 href='$5' data-original-href='$5'" );

				var fragment = parseHTML(document, html, false, makeURI(document.location.href));

				// Give the page some styles
				const mdvStyle = document.createElement('link');
				mdvStyle.rel = 'stylesheet';
				mdvStyle.type = 'text/css';
				mdvStyle.href = 'resource://mdvskin/markdown-viewer.css';
				document.head.appendChild(mdvStyle);

				const hljsStyle = document.createElement('link');
				hljsStyle.rel = 'stylesheet';
				hljsStyle.type = 'text/css';
				hljsStyle.href = 'resource://mdvskin/default.css';
				document.head.appendChild(hljsStyle);

				const printStyle = document.createElement('link');
				printStyle.rel = 'stylesheet';
				printStyle.setAttribute('media', 'print');
				printStyle.type = 'text/css';
				printStyle.href = 'resource://mdvskin/markdown-viewer-print.css';
				document.head.appendChild(printStyle);

				// Adding this is considered a good practice for mobiles
				const viewport = document.createElement('meta');
				viewport.name = 'viewport';
				viewport.content = 'width=device-width, initial-scale=1';
				document.head.appendChild(viewport);

				// Add the content
				document.body.appendChild(fragment);


				// Generate a title
				var title = document.body.querySelector('h1'); // first h1
				if (title) {
					title = title.textContent;
				}
				else {
					title = document.body.textContent.trim().split("\n")[0]; // first line
				}
				title = title.trim().substr(0, 50).replace('<', '&lt;').replace('>', '&gt;');
				document.title = title;

				// Restore the links
				var links = document.getElementsByTagName('a');

				// Files in the same folder: "fileNameRegardlessOfExtension",
				// "./fileNameRegardlessOfExtension", "." or "./". Allow any #hash-part, too.
				// Also, allow for relative (#hash-part-only) URLs within the same document.
				var linkInTheSameFolderWithHash = /^(\.|(\.\/)?[^#/\\]*)(#.*)?$/;

				// Like linkInTheSameFolderWithHash, but without extension and exluding any #hash-part.
				var linkWithNoExtension = /^(\.|(\.\/)?[^#/\\.]*)$/;

				for (var i=0; i < links.length; i++) {
					var link = links[i];
					if (!link.getAttribute('href')) {
						var originalHref = link.getAttribute('data-original-href');

						// linkInTheSameFolderWithHash also matches an empty string, so check that URL is non-empty
						if (originalHref !== '') {
							// Sanitize: Only allow links in the same folder.
							var match = linkInTheSameFolderWithHash.exec(originalHref);
							if (match) {
								var url = match[1];

								// Handling links with no extension, as used on Github pages:
								// replacing PageName with PageName.md. Also, replacing ./ with ./index.md.
								// If url is empty, then it's a #hash-part-only relative link.
								if (url !== '' && linkWithNoExtension.test(url)) {
									if (url === '.' || url === './') {
										url = 'index';
									}
									url += '.md';
								}
								if (match[3]) {
									url += match[3];
								}
								link.setAttribute('href', url);
							}
						}
					}
				}
			}
		},

		onPageError: function(aEvent) {
		}
	};
}
